<?php

namespace Drupal\Core\Gettext;

/**
 * Description of POHeader
 *
 * http://www.gnu.org/software/gettext/manual/gettext.html#Header-Entry
 *
 * Project-Id-Version
 * Report-Msgid-Bugs-To
 * Project-Id-Version
 * POT-Creation-Date
 * PO-Revision-Date
 * Last-Translator
 * Language-Team
 * Language
 * Content-Type
 * Content-Transfer-Encoding
 * Plural-Forms
 *
 * TODOs
 * - There is no MIME-version in the specs
 *
 *  Example header
 *
 * "Project-Id-Version: Drupal core (7.11)\n"
 * "POT-Creation-Date: 2012-02-12 22:59+0000\n"
 * "PO-Revision-Date: YYYY-mm-DD HH:MM+ZZZZ\n"
 * "Language-Team: Catalan\n"
 * "MIME-Version: 1.0\n"
 * "Content-Type: text/plain; charset=utf-8\n"
 * "Content-Transfer-Encoding: 8bit\n"
 * "Plural-Forms: nplurals=2; plural=(n>1);\n"

 * @author clemens
 */
class POHeader {

  private $_langcode;
  private $_projectIdVersion;
  private $_potCreationDate;
  private $_poRevisionDate;
  private $_languageTeam;
  private $_mimeVersion;
  private $_contentType;
  private $_contentTransferEncoding;
  private $_pluralForms;
  private $_authors;
  private $_po_date;

  /**
   * Creates a POHeader with default values set.
   *
   * @param type $langcode
   */
  public function __construct($langcode = NULL) {
    $this->_langcode = $langcode;
    $this->setDefaults();
  }

  static public function mapping() {
    return array(
      'Project-Id-Version' => '_projectIdVersion',
      // * Report-Msgid-Bugs-To
      'POT-Creation-Date' => '_potCreationDate',
      'PO-Revision-Date' => '_poRevisionDate',
      // * Last-Translator
      'Language-Team' => '_languageTeam',
      'MIME-Version' => '_mimeVersion',
      // * Language
      'Content-Type' => '_contentType',
      'Content-Transfer-Encoding' => '_contentTransferEncoding',
      'Plural-Forms' => '_pluralForms',
    );
  }

  function getPlural() {
    return $this->_pluralForms;
  }

  /**
   * Compile the PO header.
   */
  private function compileHeader() {
    $output = '';

    // Add language description and author as comment.
    $languages = language_list();
    $language_name = isset($languages[$this->_langcode]) ? $languages[$this->_langcode]->name : '';
    $output .= '# ' . $language_name . ' translation of ' . variable_get('site_name', 'Drupal') . "\n";
    if (!empty($this->_authors)) {
      $output .= '# Generated by ' . implode("\n# ", $this->_authors) . "\n";
    }
    $output .= "#\n";

    // Add the actual header information.
    $output .= "msgid \"\"\n";
    $output .= "msgstr \"\"\n";
    $output .= "\"Project-Id-Version: PROJECT VERSION\\n\"\n";
    $output .= "\"POT-Creation-Date: " . $this->_po_date . "\\n\"\n";
    $output .= "\"PO-Revision-Date: " . $this->_po_date . "\\n\"\n";
    $output .= "\"Last-Translator: NAME <EMAIL@ADDRESS>\\n\"\n";
    $output .= "\"Language-Team: LANGUAGE <EMAIL@ADDRESS>\\n\"\n";
    $output .= "\"MIME-Version: 1.0\\n\"\n";
    $output .= "\"Content-Type: text/plain; charset=utf-8\\n\"\n";
    $output .= "\"Content-Transfer-Encoding: 8bit\\n\"\n";
    $output .= "\"Plural-Forms: " . $this->_pluralForms . "\\n\"\n";
    $output .= "\n";

    return $output;
  }

  /**
   * Stores a given PO Header string
   *
   * TODO: the header string is cleaned by the parser :(
   *   we need to accept unclean version too
   *
   * @param type $header
   */
  public function setFromString($header) {
    $values = $this->_locale_import_parse_header($header);

    $this->setDefaults($values);
  }

  /**
   * TODO: compare with Symfony::setDefaults()
   *
   * @param type $values
   */
  public function setDefaults($values = array()) {
    $defaults = array(
      'POT-Creation-Date' => date("Y-m-d H:iO"),
      'Plural-Forms' => 'nplurals=2; plural=(n > 1);',
    );
    foreach ($defaults as $key => $value) {
      if (empty($values[$key])) {
        $values[$key] = $value;
      }
    }
    $mapping = self::mapping();
    foreach ($mapping as $key => $var) {
      if (isset($values[$key])) {
        $this->{$var} = $values[$key];
      }
    }
  }

  public function __toString() {
    $result = $this->compileHeader() . "\n";
    return $result;
  }

  /**
   * Parses a Plural-Forms entry from a Gettext Portable Object file header.
   *
   * @param $pluralforms
   *   A string containing the Plural-Forms entry.
   * @param $filepath
   *   A string containing the filepath.
   *
   * @return
   *   An array containing the number of plurals and a
   *   formula in PHP for computing the plural form.
   */
  function _locale_import_parse_plural_forms($pluralforms, $filepath) {
    // First, delete all whitespace
    $pluralforms = strtr($pluralforms, array(" " => "", "\t" => ""));

    // Select the parts that define nplurals and plural
    $nplurals = strstr($pluralforms, "nplurals=");
    if (strpos($nplurals, ";")) {
      $nplurals = substr($nplurals, 9, strpos($nplurals, ";") - 9);
    }
    else {
      return FALSE;
    }
    $plural = strstr($pluralforms, "plural=");
    if (strpos($plural, ";")) {
      $plural = substr($plural, 7, strpos($plural, ";") - 7);
    }
    else {
      return FALSE;
    }

    // Get PHP version of the plural formula
    $plural = $this->_locale_import_parse_arithmetic($plural);

    if ($plural !== FALSE) {
      return array($nplurals, $plural);
    }
    else {
      drupal_set_message(t('The translation file %filepath contains an error: the plural formula could not be parsed.', array('%filepath' => $filepath)), 'error');
      return FALSE;
    }
  }

  /**
   * Parses a Gettext Portable Object file header.
   *
   * @param $header
   *   A string containing the complete header.
   *
   * @return
   *   An associative array of key-value pairs.
   */
  function _locale_import_parse_header($header) {
    $header_parsed = array();
    $lines = array_map('trim', explode("\n", $header));
    foreach ($lines as $line) {
      if ($line) {
        list($tag, $contents) = explode(":", $line, 2);
        $header_parsed[trim($tag)] = trim($contents);
      }
    }
    return $header_parsed;
  }

  /**
   * Parses and sanitizes an arithmetic formula into a PHP expression.
   *
   * While parsing, we ensure, that the operators have the right
   * precedence and associativity.
   *
   * @param $string
   *   A string containing the arithmetic formula.
   *
   * @return
   *   The PHP version of the formula.
   */
  function _locale_import_parse_arithmetic($string) {
    // Operator precedence table
    $precedence = array("(" => -1, ")" => -1, "?" => 1, ":" => 1, "||" => 3, "&&" => 4, "==" => 5, "!=" => 5, "<" => 6, ">" => 6, "<=" => 6, ">=" => 6, "+" => 7, "-" => 7, "*" => 8, "/" => 8, "%" => 8);
    // Right associativity
    $right_associativity = array("?" => 1, ":" => 1);

    $tokens = $this->_locale_import_tokenize_formula($string);

    // Parse by converting into infix notation then back into postfix
    // Operator stack - holds math operators and symbols
    $operator_stack = array();
    // Element Stack - holds data to be operated on
    $element_stack = array();

    foreach ($tokens as $token) {
      $current_token = $token;

      // Numbers and the $n variable are simply pushed into $element_stack
      if (is_numeric($token)) {
        $element_stack[] = $current_token;
      }
      elseif ($current_token == "n") {
        $element_stack[] = '$n';
      }
      elseif ($current_token == "(") {
        $operator_stack[] = $current_token;
      }
      elseif ($current_token == ")") {
        $topop = array_pop($operator_stack);
        while (isset($topop) && ($topop != "(")) {
          $element_stack[] = $topop;
          $topop = array_pop($operator_stack);
        }
      }
      elseif (!empty($precedence[$current_token])) {
        // If it's an operator, then pop from $operator_stack into $element_stack until the
        // precedence in $operator_stack is less than current, then push into $operator_stack
        $topop = array_pop($operator_stack);
        while (isset($topop) && ($precedence[$topop] >= $precedence[$current_token]) && !(($precedence[$topop] == $precedence[$current_token]) && !empty($right_associativity[$topop]) && !empty($right_associativity[$current_token]))) {
          $element_stack[] = $topop;
          $topop = array_pop($operator_stack);
        }
        if ($topop) {
          $operator_stack[] = $topop;   // Return element to top
        }
        $operator_stack[] = $current_token;      // Parentheses are not needed
      }
      else {
        return FALSE;
      }
    }

    // Flush operator stack
    $topop = array_pop($operator_stack);
    while ($topop != NULL) {
      $element_stack[] = $topop;
      $topop = array_pop($operator_stack);
    }

    // Now extract formula from stack
    $previous_size = count($element_stack) + 1;
    while (count($element_stack) < $previous_size) {
      $previous_size = count($element_stack);
      for ($i = 2; $i < count($element_stack); $i++) {
        $op = $element_stack[$i];
        if (!empty($precedence[$op])) {
          $f = "";
          if ($op == ":") {
            $f = $element_stack[$i - 2] . "):" . $element_stack[$i - 1] . ")";
          }
          elseif ($op == "?") {
            $f = "(" . $element_stack[$i - 2] . "?(" . $element_stack[$i - 1];
          }
          else {
            $f = "(" . $element_stack[$i - 2] . $op . $element_stack[$i - 1] . ")";
          }
          array_splice($element_stack, $i - 2, 3, $f);
          break;
        }
      }
    }

    // If only one element is left, the number of operators is appropriate
    if (count($element_stack) == 1) {
      return $element_stack[0];
    }
    else {
      return FALSE;
    }
  }

  /**
   * Provides backward-compatible formula parsing for token_get_all().
   *
   * @param $string
   *   A string containing the arithmetic formula.
   *
   * @return
   *   The PHP version of the formula.
   */
  function _locale_import_tokenize_formula($formula) {
    $formula = str_replace(" ", "", $formula);
    $tokens = array();
    for ($i = 0; $i < strlen($formula); $i++) {
      if (is_numeric($formula[$i])) {
        $num = $formula[$i];
        $j = $i + 1;
        while ($j < strlen($formula) && is_numeric($formula[$j])) {
          $num .= $formula[$j];
          $j++;
        }
        $i = $j - 1;
        $tokens[] = $num;
      }
      elseif ($pos = strpos(" =<>!&|", $formula[$i])) { // We won't have a space
        $next = $formula[$i + 1];
        switch ($pos) {
          case 1:
          case 2:
          case 3:
          case 4:
            if ($next == '=') {
              $tokens[] = $formula[$i] . '=';
              $i++;
            }
            else {
              $tokens[] = $formula[$i];
            }
            break;
          case 5:
            if ($next == '&') {
              $tokens[] = '&&';
              $i++;
            }
            else {
              $tokens[] = $formula[$i];
            }
            break;
          case 6:
            if ($next == '|') {
              $tokens[] = '||';
              $i++;
            }
            else {
              $tokens[] = $formula[$i];
            }
            break;
        }
      }
      else {
        $tokens[] = $formula[$i];
      }
    }
    return $tokens;
  }

}

?>
